# Changelog

## [2025-01-19] - Расширение фильтрации заказов по техническим флагам

### Добавлено
- **Фильтрация по техническим флагам в OrderService**: Расширены методы получения и поиска заказов
  - `get_orders_list()` поддерживает фильтры по флагам: `stock_updated_filter`, `invoice_created_filter`, `invoice_id_filter`
  - `search_orders()` поддерживает те же фильтры для уточнения результатов поиска
  - Автоматический JOIN с таблицей OrderTechnicalFlags при использовании фильтров по флагам
  - Оптимизированные запросы с условным JOIN только при необходимости
  - Поддержка комбинирования всех типов фильтров: статус, даты, технические флаги, текстовый поиск

### Изменено  
- **API эндпоинты заказов**: Добавлена поддержка фильтрации по техническим флагам
  - `GET /orders/` поддерживает новые query параметры: `stock_updated`, `invoice_created`, `invoice_id`
  - `GET /orders/search` поддерживает те же параметры для уточнения результатов поиска
  - Обновлена документация API с подробным описанием возможностей фильтрации
  - Комбинирование фильтров: статус заказа + даты + технические флаги + текстовый поиск

### Исправлено
- **JOIN условия в OrderService**: Исправлена ошибка в названии поля при JOIN с OrderTechnicalFlags
  - Заменено `OrderTechnicalFlags.order_id` на `OrderTechnicalFlags.allegro_order_id` в соответствии с моделью
  - Исправлено во всех методах: `get_orders_list()`, `search_orders()` и их count запросах
  - Устранена ошибка "order_id" при использовании фильтров по техническим флагам

- **API фильтрации**: Расширена информация о примененных фильтрах в ответах API
  - Добавлены поля `stock_updated`, `invoice_created`, `invoice_id` в блок `filters` всех ответов
  - Корректная работа пагинации при фильтрации по техническим флагам
  - Точный подсчет общего количества записей с учетом всех активных фильтров

## [2025-01-19] - Создание технической модели OrderTechnicalFlags для отслеживания состояния заказов

### Добавлено
- **Техническая модель OrderTechnicalFlags**: Создана модель для отслеживания технических состояний заказов
  - Поля для отслеживания списания стока (`is_stock_updated`) и создания инвойсов (`has_invoice_created`, `invoice_id`)
  - Связь с заказами через `token_id` + `allegro_order_id` для изоляции пользователей
  - Автоматическое создание записи при первом обращении к данным заказа
  - Уникальный констрейнт для предотвращения дублирования флагов на заказ
  
- **Сервис OrderTechnicalFlagsService**: Специализированный сервис для работы с техническими флагами
  - Методы для управления флагами стока и инвойсов (`update_stock_status`, `update_invoice_status`)
  - Получение флагов с автосозданием (`get_or_create_flags`)
  - Массовое получение флагов для оптимизации запросов (`get_multiple_flags`)
  - Статистика по флагам токена (`get_flags_summary`)

- **API роуты для управления флагами**: Реализованы эндпоинты для обновления технических состояний
  - `PATCH /orders/{order_id}/stock-status` - управление флагом списания стока
  - `PATCH /orders/{order_id}/invoice-status` - управление флагами инвойсов  
  - `GET /orders/{order_id}/technical-flags` - получение текущих флагов заказа
  - `GET /orders/technical-flags/summary` - статистика по всем флагам токена

- **Миграция базы данных**: Создана таблица `order_technical_flags`
  - Поля: id, token_id, allegro_order_id, is_stock_updated, has_invoice_created, invoice_id
  - Внешний ключ на user_tokens.id
  - Уникальное ограничение на пару (token_id, allegro_order_id)

### Изменено
- **OrderService**: Интеграция технических флагов во все методы получения заказов
  - `get_orders_list()` - автоматическое включение технических флагов в список заказов
  - `search_orders()` - добавление флагов в результаты поиска
  - `get_order_details()` - включение флагов в детальную информацию заказа
  - Оптимизация запросов через массовое получение флагов

- **Стандартизация форматов API**: Полные данные заказов вместо краткой сводки
  - API теперь возвращает полные данные заказов из order_data JSON + технические флаги
  - Удалены модели OrderSummary, OrdersList, SearchResults - используется Dict[str, Any]
  - Создан единый метод `_format_order_data()` для объединения данных Allegro с техническими флагами
  - Добавлены метаданные БД: db_id, token_id, allegro_order_id, db_created_at, db_updated_at

- **Исправление поиска по заказам**: Корректная работа с JSON структурой order_data
  - Поиск по order_data['buyer']['email'], firstName, lastName, login, companyName
  - Поиск по order_data['id'] (ID заказа в Allegro)
  - Обновлен метод `_calculate_relevance()` для работы с JSON структурой
  - Добавлен фильтр по token_id для изоляции данных пользователей

### Исправлено
- **SQLAlchemy Session проблемы**: Полностью исправлена ошибка "Instance is not bound to a Session"
  - Изменен `get_multiple_flags()` для возврата обычных Python словарей вместо SQLAlchemy объектов
  - Убрана передача detached SQLAlchemy объектов между сессиями
  - Данные извлекаются и конвертируются в Python типы внутри активной сессии
  - Исправлен `_format_order_data()` для работы с словарями вместо ORM объектов

### В процессе разработки
- Unit-тесты для новой функциональности

## [2025-01-19] - Добавление эндпоинта для статуса автосинхронизации токена

### Добавлено
- **API эндпоинт `/api/v1/sync/status/{token_id}`**: Новый эндпоинт для получения статуса автосинхронизации конкретного токена
  - Позволяет фронтенду проверять, активна ли автосинхронизация для токена
  - Возвращает полную информацию о настройках автосинхронизации (интервал, статус, время последнего запуска)
  - Включает проверку принадлежности токена пользователю для безопасности

- **Pydantic модель `TokenSyncStatusResponse`**: Структурированная модель ответа статуса токена
  - Поле `is_active: bool` - основной индикатор активности автосинхронизации
  - Детальная информация о настройках: интервал, имя задачи, времена запуска
  - При неактивной автосинхронизации все дополнительные поля возвращают `None`

### Изменено
- **Контроллер sync.py**: Расширен функционал управления автосинхронизацией
  - Добавлена функция `get_sync_status_for_token()` с полной валидацией безопасности
  - Логирование всех операций получения статуса для аудита
  - Обработка исключений с информативными сообщениями об ошибках

## [2025-01-18] - Добавление поля account_name для токенов пользователей

### Добавлено
- **Поле account_name в модели UserToken**: Добавлено новое поле `account_name` для удобства идентификации аккаунтов Allegro
  - Уникальное ограничение на пару `user_id + account_name` для предотвращения дубликатов
  - Валидация уникальности происходит до момента инициализации авторизации
  - Обязательное поле во всех API запросах создания и обновления токенов

- **Обновленные API модели**: Все Pydantic модели обновлены для работы с account_name
  - `TokenCreate`: добавлено обязательное поле `account_name`
  - `TokenResponse`: добавлено поле `account_name` в ответы
  - `TokenUpdate`: добавлено опциональное поле `account_name`
  - `AuthInitializeRequest`: добавлено обязательное поле `account_name`
  - `AuthStatusRequest`: добавлено обязательное поле `account_name`

- **Валидация уникальности**: Новый метод `validate_account_name_uniqueness()` в TokenService
  - Проверяет уникальность комбинации `user_id + account_name` перед созданием токена
  - Предотвращает создание дубликатов на уровне сервиса
  - Возвращает понятные ошибки при нарушении уникальности

### Изменено
- **TokenService**: Обновлены все методы для работы с account_name
  - `create_token()`: добавлен параметр `account_name` с валидацией уникальности
  - `update_user_token()`: добавлен параметр `account_name` для обновления
  - `create_token_sync()`: добавлен параметр `account_name` для синхронных операций

- **AllegroAuthService**: Обновлены методы авторизации
  - `initialize_device_flow()`: добавлен параметр `account_name` с валидацией
  - `check_auth_status()`: добавлен параметр `account_name`
  - `check_auth_status_sync()`: добавлен параметр `account_name`

- **Все эндпоинты токенов**: Обновлены для работы с account_name
  - Создание токена: требует указания `account_name`
  - Получение токенов: возвращает `account_name` в ответах
  - Обновление токена: поддерживает обновление `account_name`
  - Инициализация авторизации: требует `account_name`
  - Проверка статуса авторизации: требует `account_name`

- **Celery задачи**: Обновлена задача `poll_authorization_status`
  - Добавлен параметр `account_name` для передачи в синхронные методы
  - Обновлены все вызовы задачи для передачи `account_name`

### Миграция БД
- Выполнена миграция для добавления поля `account_name` в таблицу `user_tokens`
- Добавлено уникальное ограничение `unique_user_account` на пару `user_id + account_name`

## [2025-01-18] - Реализация автоматического получения стартовой точки событий

### Добавлено
- **Автоматическое получение стартовой точки событий**: Реализован механизм получения текущей точки событий от Allegro API Statistics
  - Новый метод `_get_current_event_point_from_api()` для вызова `/order/events/statistics`
  - Автоматическое сохранение стартовой точки как специального события типа `SYNC_STARTING_POINT`
  - Полный fallback: если в БД нет event_id, система автоматически получает текущую точку от API

- **Улучшенная логика получения event_id**: Модернизирован метод `_get_last_event_id_from_db()`
  - При отсутствии событий в БД автоматически вызывается API Statistics
  - Сохранение полученной стартовой точки для будущих синхронизаций
  - Логирование всех этапов получения event_id

- **Новый метод сохранения стартовой точки**: Реализован `_save_starting_point_event()`
  - Создание специального события-маркера для отметки начала синхронизации
  - Сохранение event_id для корректной пагинации в будущем
  - Обработка ошибок БД без прерывания процесса

### Изменено
- **Разделение логики синхронизации**: Четко разделены грубая и тонкая синхронизация
  - Грубая синхронизация: при указании `sync_from_date` → Checkout Forms API
  - Тонкая синхронизация: без `sync_from_date` → Events API с автоматическим получением стартовой точки
  
- **Улучшенная обработка первого запуска**: При первом запуске тонкой синхронизации
  - Автоматическое получение текущей точки событий от Allegro API
  - Сохранение этой точки как стартового события
  - Все последующие синхронизации будут продолжаться с этой точки

### Протестировано
- Полное покрытие тестами новой функциональности получения стартовой точки
- Тесты для обработки ошибок API и БД
- Проверка корректности fallback логики
- Валидация сохранения стартовых событий

## [2025-07-14] - Исправление работы с Allegro API и синхронизации данных

### Исправлено
- **КРИТИЧЕСКОЕ**: Полностью переработана логика получения данных от Allegro API
  - Проблема: Система неправильно использовала Events API, который возвращает только метаданные
  - Решение: Реализована правильная логика выбора API:
    - При указании `sync_from_date` → используется Checkout Forms API с фильтрацией по датам
    - Без `sync_from_date` → используется Events API + дополнительные запросы за полными данными
  - Результат: Система теперь получает полные и корректные данные заказов

- **КРИТИЧЕСКОЕ**: Исправлена валидация данных под структуру Allegro API
  - Проблема: Валидация требовала поля, которых нет в реальных данных от Allegro
  - Решение: Адаптирована валидация под реальную структуру данных Allegro API
  - Результат: Все типы данных от Allegro API проходят валидацию

- **КРИТИЧЕСКОЕ**: Исправлено создание искусственных событий
  - Проблема: Система создавала поддельные события для заказов из Checkout Forms API
  - Решение: События сохраняются только для данных из Events API, заказы из Checkout Forms API обрабатываются напрямую
  - Результат: В базе данных хранятся только реальные события от Allegro

### Добавлено
- Новый метод `_fetch_orders_by_date()` для работы с Checkout Forms API
- Метод `_get_last_event_id_from_db()` для правильной пагинации Events API
- Обновленная логика выбора API в зависимости от параметров синхронизации
- Улучшенная обработка полных данных заказов для каждого события

### Изменено
- Переработана основная логика синхронизации в `sync_orders_safe()`
- Обновлен метод `_fetch_order_events_safe()` для получения полных данных заказов
- Адаптирована валидация данных в `OrderProtectionService` под структуру Allegro API
- Улучшено логирование процесса синхронизации

### Технические детали
- Обновлен `OrderSyncService` с правильной работой с двумя типами API
- Исправлена структурная валидация в `_validate_data_structure()`
- Добавлена поддержка всех полей Allegro API (delivery, payment, fulfillment, etc.)
- Реализована правильная пагинация через event_id для Events API
- Изменена логика в `_process_single_order_safe()` для различения источников данных
- Добавлена проверка `source` в данных для корректной обработки событий

## [2025-07-14] - Исправление критической ошибки валидации

### Исправлено
- **КРИТИЧЕСКОЕ**: Исправлена ошибка валидации данных в `OrderProtectionService`
  - Проблема: Система требовала полный набор полей для всех операций
  - Решение: Реализована дифференцированная валидация:
    - Для новых заказов: требуются все поля (id, status, buyer, lineItems)
    - Для обновлений: требуется минимальный набор (id, revision)
  - Результат: Система теперь корректно обрабатывает частичные обновления от Allegro API
- Улучшена структурная валидация данных с поддержкой поля `revision`
- Добавлено более информативное логирование ошибок валидации

### Технические детали
- Обновлен метод `validate_order_data_quality()` в `OrderProtectionService`
- Обновлен метод `_validate_data_structure()` с параметром `is_update`
- Добавлена поддержка мягкой валидации для обновлений
- Улучшена обработка ошибок с детальным логированием

### Результаты тестирования
- ✅ orders_failed: 0 (было 1000)
- ✅ events_saved: 0 ошибок
- ✅ events_deduplicated: 1000
- ✅ HTTP 200 OK для всех запросов синхронизации

## [2025-01-13] - Полная очистка моделей от allegro_account_id ✅

### Изменено
- **Концепция дедупликации**: Упрощена архитектура дедупликации
  - Убрано поле `allegro_account_id` из всех моделей
  - Дедупликация теперь происходит только в рамках `token_id`
  - Каждый токен полностью независим и работает только со своими данными

- **Модель Order**: Максимально упрощена
  - Убрано поле `allegro_account_id`
  - Убрано поле `last_sync_token_id`
  - Unique constraint: `(token_id, allegro_order_id)`
  - Осталось только: `token_id`, `allegro_order_id`, `order_data`, `order_date`, `is_deleted`

- **Модель OrderEvent**: Максимально упрощена
  - Убрано поле `allegro_account_id`
  - Убрано поле `allegro_event_id`
  - Unique constraints: `(token_id, event_id)` и `(token_id, order_id, event_type, occurred_at)`
  - Осталось только: `token_id`, `order_id`, `event_type`, `occurred_at`, `event_data`, `event_id`, `is_duplicate`

- **Модель UserToken**: Без изменений
  - Уже была максимально простой
  - Только основные поля для JWT токенов

- **DeduplicationService**: Переработан для простоты
  - Убраны все методы работы с `allegro_account_id`
  - Методы `should_process_order()` и `should_process_event()` работают только с `token_id`
  - Упрощена логика проверки дубликатов

- **OrderSyncService**: Обновлен
  - Убрано получение `allegro_account_id` из токена
  - Создание событий упрощено - используется только `event_id`

### Исправлено
- **Импорты моделей**: Убран несуществующий `OrderEventSummary`
- **Unique constraints**: Исправлены constraint'ы на использование только `token_id`
- **Миграция базы данных**: Создана новая миграция `recreate_clean_tables`

### Техническое
- Создана миграция для пересоздания всех таблиц с чистой архитектурой
- Все сервисы адаптированы под упрощенную модель данных
- Система готова к production с максимально простой архитектурой

## [2025-01-13] - Исправление логики дедупликации (per-account)

### Исправлено
- **Концепция дедупликации**: Изменена логика с глобальной на per-account
  - Дедупликация теперь происходит только в рамках одного `allegro_account_id`
  - События с одинаковыми ID от разных аккаунтов - это нормально
  - Каждый токен работает независимо для своего аккаунта
  
- **Удалены поля**: Убраны устаревшие поля
  - `Order.primary_token_id` - концепция primary token не нужна
  - `UserToken.is_primary` - каждый токен равноправен
  
- **Unique constraints**: Изменены на per-account дедупликацию
  - `Order`: unique(allegro_order_id, allegro_account_id)
  - `OrderEvent`: unique(allegro_event_id, allegro_account_id)
  - Убран constraint в UserToken

### Добавлено
- **OrderEvent.event_id**: Поле для pagination в Allegro API (параметр `from`)
- **Правильная логика DeduplicationService**: Проверки только в рамках аккаунта

## [2025-01-13] - Решение проблем дедупликации данных

### Добавлено
- **DeduplicationService**: Новый сервис для предотвращения дублирования данных
  - Проверка существования заказов перед созданием дубликатов
  - Дедупликация событий по allegro_event_id
  - Определение основного токена для аккаунта Allegro
  - Статистика дедупликации и конфликтов
  
- **Уникальные констрейнты в БД**:
  - `Order.allegro_order_id` - уникальный глобально
  - `OrderEvent.allegro_event_id` - уникальный глобально
  - `UserToken.allegro_account_id + is_primary` - только один основной токен на аккаунт

### Изменено
- **Модель Order**: Добавлены поля для дедупликации
  - `allegro_account_id` - связь с аккаунтом Allegro
  - `primary_token_id` - токен, который создал заказ
  - `last_sync_token_id` - последний токен, который обновил заказ
  
- **Модель OrderEvent**: Добавлены поля для дедупликации
  - `allegro_event_id` - ID события в Allegro
  - `allegro_account_id` - связь с аккаунтом
  - `is_duplicate` - маркер дубликата
  
- **Модель UserToken**: Добавлены поля для управления токенами
  - `allegro_account_id` - ID аккаунта Allegro
  - `allegro_user_id` - ID пользователя в Allegro
  - `token_name` - название токена
  - `is_primary` - основной токен аккаунта

### Решено
- **Проблема дублирования заказов**: Два токена одного аккаунта больше не создают дубли
- **Проблема дублирования событий**: События с одинаковыми ID обрабатываются только один раз
- **Проблема конфликтов токенов**: Четкая логика определения приоритета токенов
- **Проблема audit trail**: Полное отслеживание изменений по токенам

### Техническое
- Интеграция DeduplicationService в OrderSyncService
- Новые статистики: orders_deduplicated, events_deduplicated
- Обновлено логирование результатов синхронизации
- Добавлены проверки перед обработкой событий и заказов

## [2025-01-13] - Критические исправления дат и событий

### Исправлено
- **КРИТИЧЕСКАЯ ОШИБКА**: Неправильное извлечение дат из событий и заказов Allegro
  - order_date теперь берется из поля `boughtAt` (товаров) вместо произвольных полей
  - occurred_at теперь берется из правильного поля `occurredAt` события
  - Исправлено несоответствие дат (заказы от мая 2025 vs синхронизация от июля 2025)

### Изменено
- **Оптимизация API**: Убраны лишние запросы к Allegro API для получения деталей заказов
  - События уже содержат полные данные заказов
  - Исключены дублирующие HTTP запросы
  - Значительно ускорен процесс синхронизации

### Добавлено
- **Полное сохранение событий**: Теперь сохраняются ВСЕ события в базу данных
  - Поддержка всех типов событий: BOUGHT, FILLED_IN, READY_FOR_PROCESSING, BUYER_CANCELLED, FULFILLMENT_STATUS_CHANGED, AUTO_CANCELLED
  - Метод `_save_all_events_to_db()` для полного audit trail
  - Разделение логики сохранения событий и обработки заказов

### Техническое
- Добавлен параметр `order_date` в `OrderProtectionService.safe_order_update()`
- Обновлена структура данных в `OrderSyncService._fetch_order_events_safe()`
- Исправлена обработка дат в `_process_single_order_safe()`
- Добавлено логирование статистики сохраненных событий

## [2025-01-12] - Исправление проблемы с пропуском заказов

## [2025-01-13] - Важное открытие про Event ID в Allegro API

### Обнаружено
- **ВАЖНО**: Event ID в Allegro API НЕ является простым timestamp
- Event ID имеет структуру из 16 цифр и отличается от timestamp в миллисекундах
- Event ID работает как курсор для пагинации событий (параметр `from`)
- Event ID сортируется хронологически (больший ID = более позднее событие)

### Анализ данных
- Event ID: 1747240072400879 vs Timestamp: 1747240057921 (разность ~14.5 сек)
- Event ID: 1747240073424795 vs Timestamp: 1747240058340 (разность ~15 сек)
- Event ID: 1747240097947243 vs Timestamp: 1747240077239 (разность ~20.7 сек)

### Техническое воздействие
- Текущая логика преобразования `sync_from_date` в timestamp неверна
- Нужно найти реальный event ID, соответствующий дате
- Или использовать другой подход для инкрементальной синхронизации

### Статус
- ⚠️ **Требует исправления**: Логика работы с временными параметрами в синхронизации

## [2025-01-13] - Исправление ошибки sync_to_date

### Исправлено
- **КРИТИЧЕСКАЯ ОШИБКА**: Исправлена ошибка `name 'sync_to_date' is not defined` в OrderSyncService
- Добавлен отсутствующий параметр `sync_to_date` в функцию `sync_orders_safe`
- Обновлен log-сообщение для корректного отображения временного диапазона синхронизации
- Исправлена ошибка в order_service.py с неопределенной переменной `new_data`

### Изменено
- Сигнатура функции `sync_orders_safe` теперь включает параметр `sync_to_date: Optional[datetime] = None`
- Результат синхронизации теперь включает `sync_to_date` в отчете

### Техническое исправление
- Корректировка параметров функции для поддержки временных диапазонов синхронизации
- Обновление логики работы с Allegro API для правильной обработки event ID

## [2025-01-13] - Финальная стабилизация системы синхронизации

### Исправлено
- **КРИТИЧЕСКАЯ ОШИБКА**: Исправлена ошибка 'DataMonitoringService' object has no attribute 'detect_data_anomalies'
- Добавлен недостающий метод `detect_data_anomalies` в DataMonitoringService для анализа аномалий в событиях заказов
- Реализовано безопасное извлечение order_id из структуры событий Allegro API (order.checkoutForm.id)
- Добавлены методы валидации структуры событий и качества данных заказов

### Добавлено  
- Полная поддержка анализа аномалий в данных событий заказов
- Проверка дубликатов событий, качества данных и структурной целостности
- Методы `_validate_event_structure`, `_extract_order_id_safe`, `_validate_order_data_quality`
- Детальное логирование процесса анализа аномалий

### Результат
- ✅ **Система синхронизации полностью стабилизирована и готова к production**
- ✅ Все критические ошибки устранены
- ✅ JWT аутентификация работает корректно
- ✅ Валидация токенов и принадлежности пользователям функционирует
- ✅ OrderSyncService, DataMonitoringService и OrderProtectionService работают без ошибок

## [1.4.0] - 2025-01-13 - JWT Authentication Integration

### Добавлено
- **JWT Authentication**: Полная защита всех API endpoints через JWT токены
- **CurrentUser Model**: Извлечение user_id из JWT payload для изоляции данных пользователей
- **Безопасные API**: Все endpoints требуют аутентификации и работают только с данными текущего пользователя
- **User Context**: user_id автоматически извлекается из JWT, не передается в параметрах
- **Token Ownership**: Пользователи могут работать только со своими токенами и заказами
- **Sync API Endpoints**: Рабочие API endpoints для запуска синхронизации заказов
- **Test JWT Endpoints**: Endpoints для создания и тестирования JWT токенов
- **OrderSyncService Integration**: Интеграция сервиса синхронизации с API endpoints

### Изменено
- **user_id Type**: Возвращен тип `str` для user_id (UUID в виде строки из JWT)
- **API Endpoints Security**: Все endpoints теперь используют `CurrentUserDep` зависимость
- **Token Management**: Device Code Flow сохранен но защищен JWT токенами
- **Database Sessions**: Оптимизированы для работы с сервисами защиты данных
- **Error Handling**: Улучшена обработка ошибок с JWT контекстом

### Архитектурные решения
- **Микросервисная Архитектура**: JWT для межсервисного взаимодействия
- **Device Code Flow**: Остается в микросервисе для получения токенов Allegro
- **Security Layer**: JWT проверяется на каждом запросе
- **User Isolation**: Пользователи видят только свои данные

### API Changes
- **Breaking Change**: Все API endpoints теперь требуют `Authorization: Bearer <jwt_token>`
- **User Context**: user_id автоматически извлекается из JWT, не передается в параметрах
- **Token Ownership**: Пользователи могут работать только со своими токенами и заказами

### Исправлено
- Исправлена ошибка импорта `get_db` в OrderSyncService
- Исправлены вызовы несуществующих методов в API токенов
- Исправлена ошибка с полем `email` в JWT аутентификации
- Добавлены недостающие методы в TokenService для безопасной работы с токенами пользователей
- Исправлены вызовы AllegroAuthService без параметра db_session
- Исправлен неправильный параметр 'interval' в Celery задаче poll_authorization_status
- Исправлены методы refresh_token в TokenService и API endpoints

## [1.3.0] - 2025-01-13 - Data Protection & OrderService

### Добавлено
- **OrderProtectionService**: Защита от потери и повреждения данных
  - Append-Only архитектура для предотвращения потери данных
  - Smart data merge с сохранением максимальной информации
  - Валидация против деградации данных
  - Optimistic locking с allegro_revision
  - Механизм восстановления из событий
- **DataMonitoringService**: Мониторинг качества данных в реальном времени
  - Детекция аномалий и подозрительных паттернов
  - Circuit breaker для критических ситуаций
  - Health metrics и система алертов
  - Качественные отчеты с рекомендациями
- **OrderSyncService**: Безопасная синхронизация с интегрированной защитой
  - Pre-sync валидация качества данных
  - Transaction safety с rollback возможностями
  - Audit trail всех операций
- **OrderService**: Комплексный сервис для работы с заказами
  - Получение событий и деталей заказов от Allegro API
  - Защищенная синхронизация с data protection
  - Поиск и фильтрация заказов с пагинацией
  - Аналитика и статистика заказов
  - Мониторинг качества данных
- **Orders API**: Полнофункциональные REST endpoints
  - `GET /api/v1/orders/` - Список заказов с фильтрацией
  - `GET /api/v1/orders/search` - Поиск заказов по критериям
  - `GET /api/v1/orders/statistics` - Статистика заказов
  - `GET /api/v1/orders/events` - События от Allegro API
  - `GET /api/v1/orders/sync/history` - История синхронизации
  - `GET /api/v1/orders/data-quality` - Отчеты качества данных
  - `GET /api/v1/orders/{order_id}` - Детали заказа
  - `POST /api/v1/orders/{order_id}/sync` - Принудительная синхронизация
  - Debug endpoints для мониторинга системы

### Исправлено
- **Database Integration**: Исправлен синтаксис SQLModel во всех сервисах
  - Замена `.query()` на `.exec(select())`
  - Добавлены корректные импорты `select`, `func`
  - Исправлены типы и аннотации
- **Session Management**: Правильное управление сессиями базы данных
  - Создан `get_sync_db_session_direct()` для сервисов
  - Context managers для автоматической очистки ресурсов
- **Dependencies**: Исправлены зависимости и импорты

### Архитектура защиты данных
1. **Append-Only**: Никогда не удаляем данные, только дополняем
2. **Event Sourcing**: Полный audit trail в order_events
3. **Data Validation**: Строгая валидация с проверкой деградации
4. **Version Control**: Отслеживание allegro_revision для optimistic locking
5. **Smart Merge**: Умное слияние данных без потери информации
6. **Circuit Breaker**: Автоматическая остановка при критических аномалиях
7. **Recovery Mechanism**: Восстановление из событий до любой точки времени
8. **Real-time Monitoring**: Непрерывный мониторинг качества данных

## [1.2.0] - 2025-01-11 - Device Code Flow Completion

### Добавлено
- **Device Code Flow авторизация**: Полная реализация для Allegro API
- **Celery polling**: Автоматический опрос статуса авторизации с retry логикой
- **API эндпоинты авторизации**: 
  - `/api/v1/tokens/auth/initialize` - Инициализация авторизации
  - `/api/v1/tokens/auth/status/{device_code}` - Проверка статуса
  - `/api/v1/tokens/auth/task/{task_id}` - Статус Celery задачи
- **Автоматическое создание токенов**: При успешной авторизации
- **Обработка всех статусов**: pending, completed, failed, expired
- **Mermaid диаграмма**: Архитектура авторизации в project.md

### Исправлено
- **Критическая ошибка Celery**: Обработка retry исключений в задачах
- **Логирование**: Оптимизировано для production использования
- **Обработка ошибок**: Улучшена во всех компонентах авторизации

### Изменено
- **Debug логи**: Убраны из всех компонентов кроме Device Code Flow
- **Производительность**: Улучшена за счет оптимизации логирования

## [1.1.0] - 2025-01-10 - API и сервисы токенов

### Добавлено
- **TokenService**: Полный сервис для управления токенами пользователей
- **AllegroAuthService**: Сервис для авторизации через Allegro API  
- **API эндпоинты токенов**: CRUD операции для токенов пользователей
- **Celery задачи**: Фоновые задачи для работы с токенами
- **Обработка ошибок**: Кастомные HTTP исключения
- **Логирование**: Структурированное логирование для всех операций

### Исправлено
- **Pydantic v2**: Совместимость со всеми API моделями
- **Тестирование**: Все методы API протестированы и работают

## [1.0.0] - 2025-01-09 - Базовая инфраструктура

### Добавлено
- **Docker окружение**: Docker Compose с PostgreSQL, Redis, Celery
- **FastAPI приложение**: Базовая структура с роутерами
- **SQLModel модели**: Модели для токенов, заказов, событий, истории синхронизации
- **Celery конфигурация**: Настройка для фоновых задач
- **Alembic миграции**: Система миграций базы данных
- **Poetry управление зависимостями**: Все зависимости настроены
- **Базовые настройки**: Конфигурация через environment переменные
- **Логирование**: Настройка структурированного логирования

### Архитектурные решения
- **Event-driven архитектура**: Для синхронизации заказов
- **Микросервисная готовность**: Изолированный сервис заказов
- **Production-ready**: Docker, логирование, мониторинг
- **Масштабируемость**: Celery для фоновых задач 

## [2025-01-13] Критические исправления API

### Исправлено
- **Критическая ошибка валидации Pydantic в API**: Исправлена проблема с конвертацией `UserToken` в `TokenResponse` 
  - Проблема: `TokenResponse.model_validate(token)` не работал из-за наличия чувствительных полей в `UserToken` 
  - Решение: Заменен на явное создание `TokenResponse` с нужными полями
  - Затронутые endpoints: `/api/v1/tokens/`, `/api/v1/tokens/{id}`, обновление и валидация токенов
- **Исправлена ошибка типов в OrderService**: Изменен тип `user_id` с `int` на `str` для совместимости с JWT payload
- **Исправлены вызовы OrderService в Orders API**: Убраны лишние параметры и исправлена инициализация сервиса
- **Исправлена конфигурация Pydantic Settings**: Добавлен `extra = "ignore"` во все Config классы в `settings.py`

### Технические детали
- Все API endpoints теперь корректно работают с JWT аутентификацией
- Устранены ошибки валидации "Input should be a valid dictionary or instance of TokenResponse" 
- Исправлена ошибка "got an unexpected keyword argument 'user_id'" в OrderService
- Настройки приложения теперь игнорируют дополнительные поля из .env файла

### Тестирование
- ✅ `/api/v1/tokens/` - возвращает корректный список токенов
- ✅ `/api/v1/tokens/{id}` - возвращает корректную информацию о токене
- ✅ `/api/v1/orders/` - возвращает корректную структуру с пагинацией
- ✅ JWT аутентификация работает во всех endpoint'ах 

### Дополнительные исправления
- **Исправлены debug endpoints в Orders API**: 
  - `/debug/statuses` - добавлена заглушка со списком статусов заказов
  - `/debug/health` - добавлена заглушка с проверкой состояния системы
- **Исправлены вызовы методов OrderService**: Заменены несуществующие методы на корректные
  - `get_allegro_order_events` → `get_order_events` 
  - `get_order_by_id` → `get_order_details`
  - Убраны лишние параметры из вызовов методов
- **Критическая ошибка синхронизации**: Исправлено использование несуществующего поля `received_at`
  - Заменено на корректное поле `occurred_at` во всех сервисах защиты данных
  - OrderEvent модель использует `occurred_at` для времени события в Allegro
- **Улучшена стабильность системы**: Все API endpoints теперь работают без ошибок 500 

---

## [2024-12-19] - Подтверждение корректности дедупликации

### Подтверждено
- **Дедупликация уже правильно реализована** с учетом комбинации `(order_id, token_id)` и `(event_id, token_id)`
- Разные токены могут иметь заказы с одинаковыми `allegro_order_id` - это нормальное поведение
- Уникальные constraints в базе данных корректно настроены:
  - `UniqueConstraint("token_id", "allegro_order_id")` для таблицы `orders`
  - `UniqueConstraint("token_id", "event_id")` для таблицы `order_events`
- `DeduplicationService` корректно проверяет существование записей по комбинации полей
- `OrderSyncService` передает `token_id` во все методы дедупликации

### Документировано
- Принципы работы дедупликации для нескольких токенов
- Объяснение того, почему одинаковые ID заказов для разных токенов допустимы
- Архитектурные решения по изоляции данных токенов

--- 

## [2024-12-19] - Исправление соответствия реальной структуре Allegro API

### Исправлено
- **Логика извлечения order_id из Events API** - добавлено несколько стратегий поиска order_id в различных полях события:
  - `event.order.checkoutForm.id` (основной способ)
  - `event.order.id` (альтернативный)
  - `event.orderId` или `event.order_id` (корневой уровень)
  - Поиск по всем полям с ID-подобными значениями
- **Валидация структуры данных** в `OrderProtectionService._validate_data_structure`:
  - Исправлено поле `note` с `str` на `dict` (реальная структура: `{"text": "..."}`)
  - Добавлены новые поля согласно реальной API: `messageToSeller`, `surcharges`, `discounts`
  - Добавлена валидация структуры `note.text`
- **Диагностическое логирование** для Events API:
  - Подробный анализ структуры событий без order_id
  - Автоматический поиск потенциальных ID в различных полях
  - Улучшенная отладка для понимания реальной структуры данных

### Подтверждено соответствие
- **Checkout Forms API** (`GET /order/checkout-forms`) - структура `checkoutForms[]` обрабатывается правильно
- **Order Details API** (`GET /order/checkout-forms/{id}`) - возвращает полный объект заказа корректно
- **Извлечение дат** из `lineItems[0].boughtAt` и `updatedAt` работает согласно реальной структуре
- **Пагинация** через `offset` и `limit` для Checkout Forms API реализована правильно
- **Фильтрация по датам** через `lineItems.boughtAt.gte/lte` соответствует документации

--- 

### Изменено
- Удалены несуществующие задачи Celery (sync_order_events, full_sync_all_orders) из расписания beat для предотвращения ошибок KeyError 

### Добавлено
- Начата реализация архитектуры с отдельными очередями Celery для каждого токена (sync_{token_id}), автоматическим масштабированием воркеров и новым API для управления задачами синхронизации заказов (запуск, остановка, статус, список задач) 

### Добавлено
- Реализован API для активации/деактивации автосинхронизации по токену через celery-sqlalchemy-scheduler (POST /sync/activate, /sync/deactivate)
- Реализован мониторинг активных автосинхронизаций (GET /sync/active)
- Добавлена функция get_alchemy_session для получения SQLAlchemy ORM сессии 

### Добавлено
- Начата задача по полному покрытию тестами (unit, api, integration, celery) всех компонентов проекта, включая интеграцию с Allegro API. 

### Добавлено
- Создана структура папок для тестов (unit, api, integration, celery, factories) и добавлены базовые примеры тестов для каждого слоя. 

### Добавлено
- Начато покрытие тестами API-модуля tokens (app/api/v1/tokens.py): позитивные, негативные сценарии, edge-cases, права доступа. 

### Добавлено
- Полное покрытие тестами (unit, api, integration, celery) всех ключевых компонентов: API, сервисы, celery-задачи, интеграция с БД. Структура тестов готова для расширения и поддержки edge-cases. 

### Добавлено
- Начата задача по добавлению синхронных методов авторизации Allegro и переходу задач Celery на sync-методы 

### Изменено
- Celery-задачи авторизации теперь используют только синхронные методы AllegroAuthService
- Удалены async-вызовы и вспомогательные async-функции из задач Celery

### Добавлено
- Реализованы sync-методы (initialize_device_flow_sync, check_auth_status_sync, refresh_token_sync, validate_token_sync) в AllegroAuthService для поддержки фоновых задач 

### Добавлено
- Начат этап покрытия unit-тестами sync-методов AllegroAuthService и Celery-задач авторизации 

### Изменено
- Покрыты unit-тестами sync-методы AllegroAuthService, TokenService и Celery-задача poll_authorization_status (основные и граничные сценарии) 

### Изменено
- Начата задача по переводу всех user_id с UUID на строку (str) во всех моделях, сервисах, тестах и БД (VARCHAR(64)) 

### Исправлено
- Диагностирована и начата работа по устранению ошибки отсутствия таблиц celery beat (periodic tasks) в базе данных. Запланирована инициализация схемы. 

### Исправлено
- Реализовано автоматическое создание схемы celery_schema и таблиц для periodic tasks через скрипт и Makefile.
- Исправлен способ создания PeriodicTask: используется schedule_model и сериализация kwargs.
- Проверена успешная активация автосинхронизации через API, задача создаётся без ошибок. 

### Добавлено
- Реализована Celery-таска `refresh_all_tokens` для обновления всех токенов в базе без фильтрации по пользователям. Таска использует сервис TokenService и SQLModel-сессию, логирует результат и возвращает статистику по обновлению. 

### Добавлено
- Реализована Celery-таска `refresh_all_tokens_with_history` для массового обновления токенов с фиксацией истории выполнения в TaskHistory. 